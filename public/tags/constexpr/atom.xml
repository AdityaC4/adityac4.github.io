<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title> - constexpr</title>
    <link rel="self" type="application/atom+xml" href="https://adityac4.github.io/tags/constexpr/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://adityac4.github.io/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-10-03T00:00:00+00:00</updated>
    <id>https://adityac4.github.io/tags/constexpr/atom.xml</id>
    <entry xml:lang="en">
        <title>constexpr X86 Vector Operations: Enabling Compile-Time SIMD</title>
        <published>2025-10-03T00:00:00+00:00</published>
        <updated>2025-10-03T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://adityac4.github.io/blog/25-10-03-second-llvm-patch/"/>
        <id>https://adityac4.github.io/blog/25-10-03-second-llvm-patch/</id>
        
        <content type="html" xml:base="https://adityac4.github.io/blog/25-10-03-second-llvm-patch/">&lt;p&gt;Following my &lt;a href=&quot;https:&#x2F;&#x2F;adityac4.github.io&#x2F;blog&#x2F;22-09-25-first-llvm-patch&#x2F;&quot;&gt;initial foray into LLVM&#x27;s constexpr infrastructure&lt;&#x2F;a&gt;, I found myself drawn deeper into the fascinating world of compile-time vector computation. This second contribution focused on a fundamental class of operations: vector element extraction and insertion intrinsics. These operations represent the atomic building blocks of SIMD programming, and enabling their constexpr evaluation opens new possibilities for compile-time vector manipulation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-research-problem&quot;&gt;The Research Problem&lt;&#x2F;h2&gt;
&lt;p&gt;Modern C++ constexpr evaluation has evolved into a powerful compile-time computation system, but its integration with SIMD intrinsics remains limited. The issue was to enable constexpr evaluation for X86 vector element operations ‚Äî specifically, the intrinsics that extract and insert individual elements from vector registers.&lt;&#x2F;p&gt;
&lt;p&gt;The target builtins encompass the complete spectrum of X86 vector operations:&lt;&#x2F;p&gt;
&lt;h3 id=&quot;element-extraction-operations&quot;&gt;Element Extraction Operations&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Builtin&lt;&#x2F;th&gt;&lt;th&gt;Architecture&lt;&#x2F;th&gt;&lt;th&gt;Vector Type&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v4hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;MMX&lt;&#x2F;td&gt;&lt;td&gt;4√ó16-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 64-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v16qi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;16√ó8-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v8hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;8√ó16-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v4si&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;4√ó32-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v4sf&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;4√ó32-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract float from 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v2di&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;2√ó64-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v32qi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;32√ó8-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v16hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;16√ó16-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v8si&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;8√ó32-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v4di&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;4√ó64-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;element-insertion-operations&quot;&gt;Element Insertion Operations&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Builtin&lt;&#x2F;th&gt;&lt;th&gt;Architecture&lt;&#x2F;th&gt;&lt;th&gt;Vector Type&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v4hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;MMX&lt;&#x2F;td&gt;&lt;td&gt;4√ó16-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 64-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v16qi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;16√ó8-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v8hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;8√ó16-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v4si&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;4√ó32-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v2di&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;2√ó64-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v32qi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;32√ó8-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v16hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;16√ó16-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v8si&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;8√ó32-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v4di&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;4√ó64-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;architectural-considerations&quot;&gt;Architectural Considerations&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;the-dual-evaluator-challenge&quot;&gt;The Dual-Evaluator Challenge&lt;&#x2F;h3&gt;
&lt;p&gt;Clang&#x27;s constexpr evaluation operates through two distinct pathways, each requiring careful implementation:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;AST-based evaluator&lt;&#x2F;strong&gt; (&lt;code&gt;ExprConstant.cpp&lt;&#x2F;code&gt;): Operates during semantic analysis, working directly with &lt;code&gt;APValue&lt;&#x2F;code&gt; representations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Bytecode interpreter&lt;&#x2F;strong&gt; (&lt;code&gt;InterpBuiltin.cpp&lt;&#x2F;code&gt;): A virtual machine that executes constexpr code at compile-time&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This dual-path architecture ensures comprehensive coverage but requires maintaining semantic consistency between both evaluators.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;index-masking-a-critical-design-decision&quot;&gt;Index Masking: A Critical Design Decision&lt;&#x2F;h3&gt;
&lt;p&gt;One of the most interesting aspects of this implementation was understanding the implicit masking behavior. The Intel Intrinsics Guide specifies that vector element indices are automatically masked using the formula:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#f9f9f9;color:#111111;&quot;&gt;&lt;code&gt;&lt;span&gt;effective_index = index &amp;amp; (num_elements - 1)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This behavior is crucial for constexpr evaluation. For instance, accessing element 5 in a 4-element vector (indices 0-3) automatically becomes element 1 (5 &amp;amp; 3 = 1). This masking must be preserved in both evaluators to maintain compatibility with runtime behavior.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-type-switch-conundrum&quot;&gt;The TYPE_SWITCH Conundrum&lt;&#x2F;h3&gt;
&lt;p&gt;A particularly fascinating challenge emerged when attempting to unify the handling of integer and floating-point vector elements. The existing &lt;code&gt;TYPE_SWITCH&lt;&#x2F;code&gt; macro seemed ideal for this purpose:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;TYPE_SWITCH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(PT) &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span&gt; PT_SInt8: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span&gt; PT_UInt8: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;* ... integer cases ... *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span&gt; PT_Float: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;* ... float case ... *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, this approach failed due to a subtle interaction with Clang&#x27;s type system. The &lt;code&gt;TYPE_SWITCH&lt;&#x2F;code&gt; macro expands to include pointer and member-pointer cases, which lack the &lt;code&gt;toAPSInt()&lt;&#x2F;code&gt; method required for integer conversion:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#f9f9f9;color:#111111;&quot;&gt;&lt;code&gt;&lt;span&gt;error: no member named &amp;#39;toAPSInt&amp;#39; in &amp;#39;clang::interp::MemberPointer&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;error: no member named &amp;#39;toAPSInt&amp;#39; in &amp;#39;clang::interp::Pointer&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This limitation revealed an interesting gap in the type system&#x27;s abstraction layer, leading to a pragmatic workaround:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(PT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; PT_Float) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Handle floating-point elements directly
&lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;INT_TYPE_SWITCH_NO_BOOL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(PT) &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Handle integer elements with proper type dispatch
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This solution, while not as elegant as a unified approach, maintains type safety while avoiding the macro expansion issues. It also led to the creation of a tracking issue (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;161685&quot;&gt;#161685&lt;&#x2F;a&gt;) for future improvements to the type system infrastructure.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementation-details&quot;&gt;Implementation Details&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;the-intrinsic-to-builtin-mapping&quot;&gt;The Intrinsic-to-Builtin Mapping&lt;&#x2F;h3&gt;
&lt;p&gt;Understanding the relationship between high-level intrinsics and low-level builtins was crucial. Each Intel intrinsic maps to a specific builtin through Clang&#x27;s header system:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Example mappings from Intel headers:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;_mm_extract_epi16&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;imm&lt;&#x2F;span&gt;&lt;span&gt;) \
&lt;&#x2F;span&gt;&lt;span&gt;  ((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;short&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;__builtin_ia32_vec_ext_v8hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;((__v8hi)(__m128i)(a), (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)(imm))&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;_mm256_insert_epi32&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;imm&lt;&#x2F;span&gt;&lt;span&gt;) \
&lt;&#x2F;span&gt;&lt;span&gt;  ((__m256i)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;__builtin_ia32_vec_set_v8si&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;((__v8si)(__m256i)(a), (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)(b), (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)(imm))&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This mapping reveals the complete spectrum of operations that needed constexpr support, from MMX (64-bit) through AVX2 (256-bit) vector operations.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;comprehensive-testing-strategy&quot;&gt;Comprehensive Testing Strategy&lt;&#x2F;h3&gt;
&lt;p&gt;The testing approach required careful consideration of both evaluator paths and edge cases:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Test Coverage:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MMX operations&lt;&#x2F;strong&gt; (&lt;code&gt;mmx-builtins.c&lt;&#x2F;code&gt;): 64-bit vector operations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;SSE2 operations&lt;&#x2F;strong&gt; (&lt;code&gt;sse2-builtins.c&lt;&#x2F;code&gt;): 128-bit integer operations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;SSE4.1 operations&lt;&#x2F;strong&gt; (&lt;code&gt;sse41-builtins.c&lt;&#x2F;code&gt;): Extended 128-bit operations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;AVX2 operations&lt;&#x2F;strong&gt; (&lt;code&gt;avx2-builtins.c&lt;&#x2F;code&gt;): 256-bit vector operations&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Edge Case Validation:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Verify masking behavior: index 5 in 4-element vector ‚Üí index 1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;TEST_CONSTEXPR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm_extract_epi16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(vec, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; vec[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;])&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Test boundary conditions and type conversions  
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;TEST_CONSTEXPR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm256_extract_epi32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(vec, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;18&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; expected_value)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Validate out-of-bounds index handling
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;TEST_CONSTEXPR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm_extract_epi8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(vec, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;20&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; vec[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;])&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; 20 &amp;amp; 15 = 4
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each test used the &lt;code&gt;TEST_CONSTEXPR&lt;&#x2F;code&gt; macro to ensure compile-time evaluation, with comprehensive coverage of out-of-bounds indices to validate the masking behavior.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;insights&quot;&gt;Insights&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;the-review-process-a-learning-experience&quot;&gt;The Review Process: A Learning Experience&lt;&#x2F;h3&gt;
&lt;p&gt;The peer review process revealed several important insights about compiler engineering:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Defensive Programming&lt;&#x2F;strong&gt;: A reviewer questioned my &lt;code&gt;NumElts == 0&lt;&#x2F;code&gt; check, correctly noting that Sema guarantees vectors have at least one element. This taught me to trust the type system&#x27;s invariants rather than adding unnecessary defensive checks.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Code Structure&lt;&#x2F;strong&gt;: The discussion about switch statements for only two cases led to the deeper exploration of &lt;code&gt;TYPE_SWITCH&lt;&#x2F;code&gt; limitations, demonstrating how code review can uncover architectural issues.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;the-broader-impact&quot;&gt;The Broader Impact&lt;&#x2F;h3&gt;
&lt;p&gt;This work contributes to the growing field of compile-time computation in C++. The ability to perform vector operations at compile-time opens new possibilities for:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Template Metaprogramming&lt;&#x2F;strong&gt;: Vector operations in template contexts&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Compile-time Optimization&lt;&#x2F;strong&gt;: Pre-computed vector tables and lookup structures&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Scientific Computing&lt;&#x2F;strong&gt;: Constexpr mathematical libraries with SIMD acceleration&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Embedded Systems&lt;&#x2F;strong&gt;: Compile-time vector processing for resource-constrained environments&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;future-directions&quot;&gt;Future Directions&lt;&#x2F;h2&gt;
&lt;p&gt;The constexpr vector intrinsics work represents just the beginning of a larger research agenda. Several exciting directions emerge:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Extended SIMD Support&lt;&#x2F;strong&gt;: AVX-512 and future instruction sets&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Cross-Platform Abstraction&lt;&#x2F;strong&gt;: Unified constexpr SIMD across different architectures&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Performance Analysis&lt;&#x2F;strong&gt;: Measuring the impact of compile-time vector computation&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Language Integration&lt;&#x2F;strong&gt;: Exploring how constexpr SIMD fits into broader C++ evolution&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;This contribution represents a significant step forward in making C++ constexpr evaluation more powerful and practical. By enabling vector element operations at compile-time, we&#x27;ve opened new possibilities for high-performance, template-based programming.&lt;&#x2F;p&gt;
&lt;p&gt;The journey from initial implementation through peer review to final integration taught me valuable lessons about compiler engineering, type systems, and the collaborative nature of open-source development. Most importantly, it demonstrated how seemingly small changes can have far-reaching implications for the C++ ecosystem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Issue&lt;&#x2F;strong&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;159753&quot;&gt;#159753&lt;&#x2F;a&gt; - Original feature request&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pull Request&lt;&#x2F;strong&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;pull&#x2F;161302&quot;&gt;#161302&lt;&#x2F;a&gt; - Implementation and discussion&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Tracking Issue&lt;&#x2F;strong&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;161685&quot;&gt;#161685&lt;&#x2F;a&gt; - Future type system improvements&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Intel Intrinsics Guide&lt;&#x2F;strong&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;software.intel.com&#x2F;sites&#x2F;landingpage&#x2F;IntrinsicsGuide&#x2F;&quot;&gt;Software Developer Manual&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;media1.giphy.com&#x2F;media&#x2F;v1.Y2lkPTc5MGI3NjExazY1anBhMmU1OWE0Mmhsd2U2dW92enR5M2JyOG15M3ppdzc5MGMwYSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw&#x2F;3og0IPWGMUALW36f9m&#x2F;giphy.gif&quot; alt=&quot;success gif&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>My First LLVM Patch: Making AVX&#x2F;AVX512 Subvector Insert Intrinsics `constexpr`</title>
        <published>2025-09-22T00:00:00+00:00</published>
        <updated>2025-09-22T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://adityac4.github.io/blog/22-09-25-first-llvm-patch/"/>
        <id>https://adityac4.github.io/blog/22-09-25-first-llvm-patch/</id>
        
        <content type="html" xml:base="https://adityac4.github.io/blog/22-09-25-first-llvm-patch/">&lt;p&gt;Recently I had decided to contribute my first patch to LLVM ‚Äî a small but surprisingly tricky update to enable &lt;code&gt;constexpr&lt;&#x2F;code&gt; support for AVX and AVX512 subvector insert intrinsics. The kind of patch where you think &quot;how hard can this be?&quot; and then two days later you&#x27;re debugging vector lanes in an interpreter VM you didn&#x27;t know existed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-why&quot;&gt;The Why&lt;&#x2F;h2&gt;
&lt;p&gt;The goal: make intrinsics like &lt;code&gt;_mm256_insertf128_ps&lt;&#x2F;code&gt; usable in &lt;code&gt;constexpr&lt;&#x2F;code&gt; functions. These are commonly used in high-performance SIMD code, and enabling them in constant evaluation can help optimize compile-time expressions, especially when building vector tables or reshuffling constants.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;trying-it&quot;&gt;Trying it&lt;&#x2F;h2&gt;
&lt;p&gt;I started with the most scientific approach available: I wrote a test case and waited for it to fail.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;constexpr&lt;&#x2F;span&gt;&lt;span&gt; __m256 result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm256_insertf128_ps&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm256_setzero_ps&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm_set1_ps&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;1.0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And thankfully it failed. The constant evaluator didn&#x27;t know what to do with the builtin, and the interpreter threw up its hands, gracefully.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-real-work&quot;&gt;The Real Work&lt;&#x2F;h2&gt;
&lt;p&gt;To fix this, I had to teach both:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ExprConstant.cpp&lt;&#x2F;code&gt;: Clang&#x27;s AST evaluator, used for folding during semantic analysis.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;InterpBuiltin.cpp&lt;&#x2F;code&gt;: the bytecode interpreter, which runs &lt;code&gt;constexpr&lt;&#x2F;code&gt; code on a tiny VM. (the future)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The logic is the same in both:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Take the base and subvector.&lt;&#x2F;li&gt;
&lt;li&gt;Check that their sizes are compatible.&lt;&#x2F;li&gt;
&lt;li&gt;Compute the insertion offset using the immediate operand.&lt;&#x2F;li&gt;
&lt;li&gt;Copy over the subvector lane into the base.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;It‚Äôs not hard logic. But LLVM‚Äôs interpreters work at a pretty low level, and everything is abstracted (you deal with &lt;code&gt;APValue&lt;&#x2F;code&gt; and &lt;code&gt;Pointer&lt;&#x2F;code&gt; wrappers, type metadata, etc). Every copy feels like handling memory with oven mitts.&lt;&#x2F;p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;
    flowchart LR
    A[&amp;quot;_mm256_insertf128_ps(...) in user code&amp;quot;] --&amp;gt; B[Clang Parser]
    B --&amp;gt; C[&amp;quot;AST: CallExpr to builtin wrapper&amp;quot;]
    C --&amp;gt; D{&amp;quot;Constant Evaluation?&amp;lt;br&amp;#x2F;&amp;gt;(in constexpr&amp;#x2F;constinit)&amp;quot;}
    D -- &amp;quot;No&amp;quot; --&amp;gt; E[Emit IR normally]
    D -- &amp;quot;Yes&amp;quot; --&amp;gt; F[&amp;quot;ExprConstant.cpp&amp;lt;br&amp;#x2F;&amp;gt;VectorExprEvaluator::VisitCallExpr&amp;quot;]
    F --&amp;gt; G{Builtin supported?}
    G -- &amp;quot;Yes&amp;quot; --&amp;gt; H[Evaluate lanes, build APValue]
    H --&amp;gt; I[Constant-folded value available to Sema]
    G -- &amp;quot;No&amp;quot; --&amp;gt; J[&amp;quot;Bytecode path:&amp;lt;br&amp;#x2F;&amp;gt;InterpBuiltin.cpp::interp_*&amp;quot;]
    J --&amp;gt; K[&amp;quot;Execute on constexpr VM,&amp;lt;br&amp;#x2F;&amp;gt;produce APValue&amp;quot;]
    I --&amp;gt; L[CodeGen uses folded constant]
    K --&amp;gt; L
    subgraph &amp;quot;Headers &amp;#x2F; Builtins&amp;quot;
      M[BuiltinsX86.td maps intrinsics] --&amp;gt; N[&amp;quot;clang&amp;#x2F;include&amp;#x2F;clang&amp;#x2F;Headers&amp;#x2F;...&amp;quot;]
    end
    M -.-&amp;gt; C
    N -.-&amp;gt; C
&lt;&#x2F;pre&gt;&lt;h2 id=&quot;builtinsx86-td-the-treasure-map&quot;&gt;BuiltinsX86.td: The Treasure Map&lt;&#x2F;h2&gt;
&lt;p&gt;Adding a new builtin means updating &lt;code&gt;BuiltinsX86.td&lt;&#x2F;code&gt;. This file maps frontend-level intrinsics to backend builtins and includes type info, masks, variants, etc.&lt;&#x2F;p&gt;
&lt;p&gt;It took me a while to understand that I didn‚Äôt need to reimplement any masking behavior. I had assumed I would need to manually interpret the mask register (‚Äúif bit i is set, write lane i‚Äù), but it turns out Clang‚Äôs headers expand these into separate builtins entirely, and the mask is passed through as a normal argument. Huge relief.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;testing-and-some-cleanup&quot;&gt;Testing (and some cleanup)&lt;&#x2F;h2&gt;
&lt;p&gt;Originally I wrote a new file: &lt;code&gt;avx-insert-constexpr.cpp&lt;&#x2F;code&gt;. But I was gently nudged by reviewers to follow the existing structure and add tests in the appropriate &lt;code&gt;clang&#x2F;test&#x2F;CodeGen&#x2F;X86&lt;&#x2F;code&gt; files.&lt;&#x2F;p&gt;
&lt;p&gt;So I did.&lt;&#x2F;p&gt;
&lt;p&gt;Over 40 new test cases, all using the &lt;code&gt;TEST_CONSTEXPR&lt;&#x2F;code&gt; macro to make sure the evaluation actually happens at compile time. Here&#x27;s a representative one:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Yes, this is one line in the actual test
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;TEST_CONSTEXPR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;match_v16si&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm512_mask_inserti32x4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(((__m512i)(__v16si){&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;17&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;}), (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x00F0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;), ((__m512i)(__v16si){&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;17&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;}), ((__m128i)(__v4si){&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;20&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;40&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;}), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;20&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;40&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;17&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;))&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Simple, but satisfying.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;review-feedback&quot;&gt;Review Feedback&lt;&#x2F;h2&gt;
&lt;p&gt;Most of the comments were around naming (I had &lt;code&gt;DstVec&lt;&#x2F;code&gt;, &lt;code&gt;Dst&lt;&#x2F;code&gt;, &lt;code&gt;Result&lt;&#x2F;code&gt; all floating around with conflicting meanings) and LLVM&#x27;s legendary formatting rules. There&#x27;s a rule about 80 columns. It‚Äôs not just a suggestion.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(SubElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; BaseElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(BaseElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; SubElements) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That became:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;assert(SubElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; BaseElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;amp;&amp;amp;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;       (BaseElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; SubElements) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(The reviewers and the llvm bot &lt;em&gt;will&lt;&#x2F;em&gt; notice.)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;merge&quot;&gt;Merge!&lt;&#x2F;h2&gt;
&lt;p&gt;Eventually, the reviewers signed off. CI passed. I rebased, squashed, and hit &quot;Mark as ready&quot;. A few hours later, it was merged.&lt;&#x2F;p&gt;
&lt;p&gt;üéâ First LLVM patch in!&lt;&#x2F;p&gt;
&lt;p&gt;PR: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;pull&#x2F;158778&quot;&gt;llvm&#x2F;llvm-project&#x2F;pull&#x2F;158778&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Issue: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;157709&quot;&gt;#157709&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;closing-thoughts&quot;&gt;Closing Thoughts&lt;&#x2F;h2&gt;
&lt;p&gt;I learned more than I expected:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;About &lt;code&gt;constexpr&lt;&#x2F;code&gt;, sure. But also about Clang internals, how intrinsics flow through the frontend, and the lovely balance between AST and interpreter.&lt;&#x2F;li&gt;
&lt;li&gt;LLVM has a steep curve, but the community‚Äôs been welcoming and helpful. (Special thanks to the reviewers!)&lt;&#x2F;li&gt;
&lt;li&gt;It felt good to contribute something useful. Even if it&#x27;s &quot;just&quot; &lt;code&gt;constexpr&lt;&#x2F;code&gt; for a few AVX intrinsics, it&#x27;s a real feature used by real code.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;media0.giphy.com&#x2F;media&#x2F;v1.Y2lkPTc5MGI3NjExeTg3YTY0MGZ0cnVsNDEwemg1bjM1dWV0ZGMyaWt4aWc4NjZja3c0dSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw&#x2F;BMR4cgypuglVu&#x2F;giphy.gif&quot; alt=&quot;fabulous cat&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
