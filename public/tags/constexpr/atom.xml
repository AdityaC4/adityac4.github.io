<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title> - constexpr</title>
    <link rel="self" type="application/atom+xml" href="https://adityac4.github.io/tags/constexpr/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://adityac4.github.io/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-10-03T00:00:00+00:00</updated>
    <id>https://adityac4.github.io/tags/constexpr/atom.xml</id>
    <entry xml:lang="en">
        <title>constexpr X86 Vector Operations: Enabling Compile-Time SIMD</title>
        <published>2025-10-03T00:00:00+00:00</published>
        <updated>2025-10-03T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://adityac4.github.io/blog/25-10-03-second-llvm-patch/"/>
        <id>https://adityac4.github.io/blog/25-10-03-second-llvm-patch/</id>
        
        <content type="html" xml:base="https://adityac4.github.io/blog/25-10-03-second-llvm-patch/">&lt;p&gt;Following my &lt;a href=&quot;https:&#x2F;&#x2F;adityac4.github.io&#x2F;blog&#x2F;22-09-25-first-llvm-patch&#x2F;&quot;&gt;initial foray into LLVM&#x27;s constexpr infrastructure&lt;&#x2F;a&gt;, I found myself drawn deeper into the fascinating world of compile-time vector computation. This second contribution focused on a fundamental class of operations: vector element extraction and insertion intrinsics. These operations represent the atomic building blocks of SIMD programming, and enabling their constexpr evaluation opens new possibilities for compile-time vector manipulation.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-research-problem&quot;&gt;The Research Problem&lt;&#x2F;h2&gt;
&lt;p&gt;Modern C++ constexpr evaluation has evolved into a powerful compile-time computation system, but its integration with SIMD intrinsics remains limited. The issue was to enable constexpr evaluation for X86 vector element operations — specifically, the intrinsics that extract and insert individual elements from vector registers.&lt;&#x2F;p&gt;
&lt;p&gt;The target builtins encompass the complete spectrum of X86 vector operations:&lt;&#x2F;p&gt;
&lt;h3 id=&quot;element-extraction-operations&quot;&gt;Element Extraction Operations&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Builtin&lt;&#x2F;th&gt;&lt;th&gt;Architecture&lt;&#x2F;th&gt;&lt;th&gt;Vector Type&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v4hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;MMX&lt;&#x2F;td&gt;&lt;td&gt;4×16-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 64-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v16qi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;16×8-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v8hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;8×16-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v4si&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;4×32-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v4sf&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;4×32-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract float from 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v2di&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;2×64-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v32qi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;32×8-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v16hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;16×16-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v8si&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;8×32-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_ext_v4di&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;4×64-bit&lt;&#x2F;td&gt;&lt;td&gt;Extract from 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;element-insertion-operations&quot;&gt;Element Insertion Operations&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Builtin&lt;&#x2F;th&gt;&lt;th&gt;Architecture&lt;&#x2F;th&gt;&lt;th&gt;Vector Type&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v4hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;MMX&lt;&#x2F;td&gt;&lt;td&gt;4×16-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 64-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v16qi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;16×8-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v8hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;8×16-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v4si&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;4×32-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v2di&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;SSE&lt;&#x2F;td&gt;&lt;td&gt;2×64-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 128-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v32qi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;32×8-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v16hi&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;16×16-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v8si&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;8×32-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;__builtin_ia32_vec_set_v4di&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;AVX2&lt;&#x2F;td&gt;&lt;td&gt;4×64-bit&lt;&#x2F;td&gt;&lt;td&gt;Insert into 256-bit vector&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;architectural-considerations&quot;&gt;Architectural Considerations&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;the-dual-evaluator-challenge&quot;&gt;The Dual-Evaluator Challenge&lt;&#x2F;h3&gt;
&lt;p&gt;Clang&#x27;s constexpr evaluation operates through two distinct pathways, each requiring careful implementation:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;AST-based evaluator&lt;&#x2F;strong&gt; (&lt;code&gt;ExprConstant.cpp&lt;&#x2F;code&gt;): Operates during semantic analysis, working directly with &lt;code&gt;APValue&lt;&#x2F;code&gt; representations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Bytecode interpreter&lt;&#x2F;strong&gt; (&lt;code&gt;InterpBuiltin.cpp&lt;&#x2F;code&gt;): A virtual machine that executes constexpr code at compile-time&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;This dual-path architecture ensures comprehensive coverage but requires maintaining semantic consistency between both evaluators.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;index-masking-a-critical-design-decision&quot;&gt;Index Masking: A Critical Design Decision&lt;&#x2F;h3&gt;
&lt;p&gt;One of the most interesting aspects of this implementation was understanding the implicit masking behavior. The Intel Intrinsics Guide specifies that vector element indices are automatically masked using the formula:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#f9f9f9;color:#111111;&quot;&gt;&lt;code&gt;&lt;span&gt;effective_index = index &amp;amp; (num_elements - 1)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This behavior is crucial for constexpr evaluation. For instance, accessing element 5 in a 4-element vector (indices 0-3) automatically becomes element 1 (5 &amp;amp; 3 = 1). This masking must be preserved in both evaluators to maintain compatibility with runtime behavior.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;the-type-switch-conundrum&quot;&gt;The TYPE_SWITCH Conundrum&lt;&#x2F;h3&gt;
&lt;p&gt;A particularly fascinating challenge emerged when attempting to unify the handling of integer and floating-point vector elements. The existing &lt;code&gt;TYPE_SWITCH&lt;&#x2F;code&gt; macro seemed ideal for this purpose:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;TYPE_SWITCH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(PT) &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span&gt; PT_SInt8: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span&gt; PT_UInt8: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;* ... integer cases ... *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;case&lt;&#x2F;span&gt;&lt;span&gt; PT_Float: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;* ... float case ... *&#x2F;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;However, this approach failed due to a subtle interaction with Clang&#x27;s type system. The &lt;code&gt;TYPE_SWITCH&lt;&#x2F;code&gt; macro expands to include pointer and member-pointer cases, which lack the &lt;code&gt;toAPSInt()&lt;&#x2F;code&gt; method required for integer conversion:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#f9f9f9;color:#111111;&quot;&gt;&lt;code&gt;&lt;span&gt;error: no member named &amp;#39;toAPSInt&amp;#39; in &amp;#39;clang::interp::MemberPointer&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;error: no member named &amp;#39;toAPSInt&amp;#39; in &amp;#39;clang::interp::Pointer&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This limitation revealed an interesting gap in the type system&#x27;s abstraction layer, leading to a pragmatic workaround:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(PT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; PT_Float) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Handle floating-point elements directly
&lt;&#x2F;span&gt;&lt;span&gt;} &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;INT_TYPE_SWITCH_NO_BOOL&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(PT) &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Handle integer elements with proper type dispatch
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This solution, while not as elegant as a unified approach, maintains type safety while avoiding the macro expansion issues. It also led to the creation of a tracking issue (&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;161685&quot;&gt;#161685&lt;&#x2F;a&gt;) for future improvements to the type system infrastructure.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;implementation-details&quot;&gt;Implementation Details&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;the-intrinsic-to-builtin-mapping&quot;&gt;The Intrinsic-to-Builtin Mapping&lt;&#x2F;h3&gt;
&lt;p&gt;Understanding the relationship between high-level intrinsics and low-level builtins was crucial. Each Intel intrinsic maps to a specific builtin through Clang&#x27;s header system:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Example mappings from Intel headers:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;_mm_extract_epi16&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;imm&lt;&#x2F;span&gt;&lt;span&gt;) \
&lt;&#x2F;span&gt;&lt;span&gt;  ((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt;)(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;short&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;__builtin_ia32_vec_ext_v8hi&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;((__v8hi)(__m128i)(a), (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)(imm))&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;_mm256_insert_epi32&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;a&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;b&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;imm&lt;&#x2F;span&gt;&lt;span&gt;) \
&lt;&#x2F;span&gt;&lt;span&gt;  ((__m256i)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;__builtin_ia32_vec_set_v8si&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;((__v8si)(__m256i)(a), (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)(b), (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)(imm))&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This mapping reveals the complete spectrum of operations that needed constexpr support, from MMX (64-bit) through AVX2 (256-bit) vector operations.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;comprehensive-testing-strategy&quot;&gt;Comprehensive Testing Strategy&lt;&#x2F;h3&gt;
&lt;p&gt;The testing approach required careful consideration of both evaluator paths and edge cases:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Test Coverage:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MMX operations&lt;&#x2F;strong&gt; (&lt;code&gt;mmx-builtins.c&lt;&#x2F;code&gt;): 64-bit vector operations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;SSE2 operations&lt;&#x2F;strong&gt; (&lt;code&gt;sse2-builtins.c&lt;&#x2F;code&gt;): 128-bit integer operations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;SSE4.1 operations&lt;&#x2F;strong&gt; (&lt;code&gt;sse41-builtins.c&lt;&#x2F;code&gt;): Extended 128-bit operations&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;AVX2 operations&lt;&#x2F;strong&gt; (&lt;code&gt;avx2-builtins.c&lt;&#x2F;code&gt;): 256-bit vector operations&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Edge Case Validation:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Verify masking behavior: index 5 in 4-element vector → index 1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;TEST_CONSTEXPR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm_extract_epi16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(vec, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; vec[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;])&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Test boundary conditions and type conversions  
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;TEST_CONSTEXPR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm256_extract_epi32&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(vec, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;18&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; expected_value)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Validate out-of-bounds index handling
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;TEST_CONSTEXPR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm_extract_epi8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(vec, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;20&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; vec[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;])&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; 20 &amp;amp; 15 = 4
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each test used the &lt;code&gt;TEST_CONSTEXPR&lt;&#x2F;code&gt; macro to ensure compile-time evaluation, with comprehensive coverage of out-of-bounds indices to validate the masking behavior.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;insights&quot;&gt;Insights&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;the-review-process-a-learning-experience&quot;&gt;The Review Process: A Learning Experience&lt;&#x2F;h3&gt;
&lt;p&gt;The peer review process revealed several important insights about compiler engineering:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Defensive Programming&lt;&#x2F;strong&gt;: A reviewer questioned my &lt;code&gt;NumElts == 0&lt;&#x2F;code&gt; check, correctly noting that Sema guarantees vectors have at least one element. This taught me to trust the type system&#x27;s invariants rather than adding unnecessary defensive checks.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Code Structure&lt;&#x2F;strong&gt;: The discussion about switch statements for only two cases led to the deeper exploration of &lt;code&gt;TYPE_SWITCH&lt;&#x2F;code&gt; limitations, demonstrating how code review can uncover architectural issues.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;the-broader-impact&quot;&gt;The Broader Impact&lt;&#x2F;h3&gt;
&lt;p&gt;This work contributes to the growing field of compile-time computation in C++. The ability to perform vector operations at compile-time opens new possibilities for:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Template Metaprogramming&lt;&#x2F;strong&gt;: Vector operations in template contexts&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Compile-time Optimization&lt;&#x2F;strong&gt;: Pre-computed vector tables and lookup structures&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Scientific Computing&lt;&#x2F;strong&gt;: Constexpr mathematical libraries with SIMD acceleration&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Embedded Systems&lt;&#x2F;strong&gt;: Compile-time vector processing for resource-constrained environments&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;future-directions&quot;&gt;Future Directions&lt;&#x2F;h2&gt;
&lt;p&gt;The constexpr vector intrinsics work represents just the beginning of a larger research agenda. Several exciting directions emerge:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Extended SIMD Support&lt;&#x2F;strong&gt;: AVX-512 and future instruction sets&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Cross-Platform Abstraction&lt;&#x2F;strong&gt;: Unified constexpr SIMD across different architectures&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Performance Analysis&lt;&#x2F;strong&gt;: Measuring the impact of compile-time vector computation&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Language Integration&lt;&#x2F;strong&gt;: Exploring how constexpr SIMD fits into broader C++ evolution&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;This contribution represents a significant step forward in making C++ constexpr evaluation more powerful and practical. By enabling vector element operations at compile-time, we&#x27;ve opened new possibilities for high-performance, template-based programming.&lt;&#x2F;p&gt;
&lt;p&gt;The journey from initial implementation through peer review to final integration taught me valuable lessons about compiler engineering, type systems, and the collaborative nature of open-source development. Most importantly, it demonstrated how seemingly small changes can have far-reaching implications for the C++ ecosystem.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Issue&lt;&#x2F;strong&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;159753&quot;&gt;#159753&lt;&#x2F;a&gt; - Original feature request&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pull Request&lt;&#x2F;strong&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;pull&#x2F;161302&quot;&gt;#161302&lt;&#x2F;a&gt; - Implementation and discussion&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Tracking Issue&lt;&#x2F;strong&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;161685&quot;&gt;#161685&lt;&#x2F;a&gt; - Future type system improvements&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Intel Intrinsics Guide&lt;&#x2F;strong&gt;: &lt;a href=&quot;https:&#x2F;&#x2F;software.intel.com&#x2F;sites&#x2F;landingpage&#x2F;IntrinsicsGuide&#x2F;&quot;&gt;Software Developer Manual&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;media1.giphy.com&#x2F;media&#x2F;v1.Y2lkPTc5MGI3NjExazY1anBhMmU1OWE0Mmhsd2U2dW92enR5M2JyOG15M3ppdzc5MGMwYSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw&#x2F;3og0IPWGMUALW36f9m&#x2F;giphy.gif&quot; alt=&quot;success gif&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>My First LLVM Patch: Making AVX&#x2F;AVX512 Subvector Insert Intrinsics `constexpr`</title>
        <published>2025-09-22T00:00:00+00:00</published>
        <updated>2025-09-22T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Unknown
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://adityac4.github.io/blog/22-09-25-first-llvm-patch/"/>
        <id>https://adityac4.github.io/blog/22-09-25-first-llvm-patch/</id>
        
        <content type="html" xml:base="https://adityac4.github.io/blog/22-09-25-first-llvm-patch/">&lt;p&gt;Recently I had decided to contribute my first patch to LLVM — a small but surprisingly tricky update to enable &lt;code&gt;constexpr&lt;&#x2F;code&gt; support for AVX and AVX512 subvector insert intrinsics. The kind of patch where you think &quot;how hard can this be?&quot; and then two days later you&#x27;re debugging vector lanes in an interpreter VM you didn&#x27;t know existed.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-why&quot;&gt;The Why&lt;&#x2F;h2&gt;
&lt;p&gt;The goal: make intrinsics like &lt;code&gt;_mm256_insertf128_ps&lt;&#x2F;code&gt; usable in &lt;code&gt;constexpr&lt;&#x2F;code&gt; functions. These are commonly used in high-performance SIMD code, and enabling them in constant evaluation can help optimize compile-time expressions, especially when building vector tables or reshuffling constants.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;trying-it&quot;&gt;Trying it&lt;&#x2F;h2&gt;
&lt;p&gt;I started with the most scientific approach available: I wrote a test case and waited for it to fail.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;constexpr&lt;&#x2F;span&gt;&lt;span&gt; __m256 result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm256_insertf128_ps&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm256_setzero_ps&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm_set1_ps&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;1.0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8959a8;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And thankfully it failed. The constant evaluator didn&#x27;t know what to do with the builtin, and the interpreter threw up its hands, gracefully.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-real-work&quot;&gt;The Real Work&lt;&#x2F;h2&gt;
&lt;p&gt;To fix this, I had to teach both:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ExprConstant.cpp&lt;&#x2F;code&gt;: Clang&#x27;s AST evaluator, used for folding during semantic analysis.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;InterpBuiltin.cpp&lt;&#x2F;code&gt;: the bytecode interpreter, which runs &lt;code&gt;constexpr&lt;&#x2F;code&gt; code on a tiny VM. (the future)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The logic is the same in both:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Take the base and subvector.&lt;&#x2F;li&gt;
&lt;li&gt;Check that their sizes are compatible.&lt;&#x2F;li&gt;
&lt;li&gt;Compute the insertion offset using the immediate operand.&lt;&#x2F;li&gt;
&lt;li&gt;Copy over the subvector lane into the base.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;It’s not hard logic. But LLVM’s interpreters work at a pretty low level, and everything is abstracted (you deal with &lt;code&gt;APValue&lt;&#x2F;code&gt; and &lt;code&gt;Pointer&lt;&#x2F;code&gt; wrappers, type metadata, etc). Every copy feels like handling memory with oven mitts.&lt;&#x2F;p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;
    flowchart LR
    A[&amp;quot;_mm256_insertf128_ps(...) in user code&amp;quot;] --&amp;gt; B[Clang Parser]
    B --&amp;gt; C[&amp;quot;AST: CallExpr to builtin wrapper&amp;quot;]
    C --&amp;gt; D{&amp;quot;Constant Evaluation?&amp;lt;br&amp;#x2F;&amp;gt;(in constexpr&amp;#x2F;constinit)&amp;quot;}
    D -- &amp;quot;No&amp;quot; --&amp;gt; E[Emit IR normally]
    D -- &amp;quot;Yes&amp;quot; --&amp;gt; F[&amp;quot;ExprConstant.cpp&amp;lt;br&amp;#x2F;&amp;gt;VectorExprEvaluator::VisitCallExpr&amp;quot;]
    F --&amp;gt; G{Builtin supported?}
    G -- &amp;quot;Yes&amp;quot; --&amp;gt; H[Evaluate lanes, build APValue]
    H --&amp;gt; I[Constant-folded value available to Sema]
    G -- &amp;quot;No&amp;quot; --&amp;gt; J[&amp;quot;Bytecode path:&amp;lt;br&amp;#x2F;&amp;gt;InterpBuiltin.cpp::interp_*&amp;quot;]
    J --&amp;gt; K[&amp;quot;Execute on constexpr VM,&amp;lt;br&amp;#x2F;&amp;gt;produce APValue&amp;quot;]
    I --&amp;gt; L[CodeGen uses folded constant]
    K --&amp;gt; L
    subgraph &amp;quot;Headers &amp;#x2F; Builtins&amp;quot;
      M[BuiltinsX86.td maps intrinsics] --&amp;gt; N[&amp;quot;clang&amp;#x2F;include&amp;#x2F;clang&amp;#x2F;Headers&amp;#x2F;...&amp;quot;]
    end
    M -.-&amp;gt; C
    N -.-&amp;gt; C
&lt;&#x2F;pre&gt;&lt;h2 id=&quot;builtinsx86-td-the-treasure-map&quot;&gt;BuiltinsX86.td: The Treasure Map&lt;&#x2F;h2&gt;
&lt;p&gt;Adding a new builtin means updating &lt;code&gt;BuiltinsX86.td&lt;&#x2F;code&gt;. This file maps frontend-level intrinsics to backend builtins and includes type info, masks, variants, etc.&lt;&#x2F;p&gt;
&lt;p&gt;It took me a while to understand that I didn’t need to reimplement any masking behavior. I had assumed I would need to manually interpret the mask register (“if bit i is set, write lane i”), but it turns out Clang’s headers expand these into separate builtins entirely, and the mask is passed through as a normal argument. Huge relief.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;testing-and-some-cleanup&quot;&gt;Testing (and some cleanup)&lt;&#x2F;h2&gt;
&lt;p&gt;Originally I wrote a new file: &lt;code&gt;avx-insert-constexpr.cpp&lt;&#x2F;code&gt;. But I was gently nudged by reviewers to follow the existing structure and add tests in the appropriate &lt;code&gt;clang&#x2F;test&#x2F;CodeGen&#x2F;X86&lt;&#x2F;code&gt; files.&lt;&#x2F;p&gt;
&lt;p&gt;So I did.&lt;&#x2F;p&gt;
&lt;p&gt;Over 40 new test cases, all using the &lt;code&gt;TEST_CONSTEXPR&lt;&#x2F;code&gt; macro to make sure the evaluation actually happens at compile time. Here&#x27;s a representative one:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#8e908c;&quot;&gt;&#x2F;&#x2F; Yes, this is one line in the actual test
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;TEST_CONSTEXPR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;match_v16si&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;_mm512_mask_inserti32x4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(((__m512i)(__v16si){&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;17&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;}), (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0x00F0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;), ((__m512i)(__v16si){&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;6&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;9&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;17&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;}), ((__m128i)(__v4si){&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;20&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;40&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;,&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;}), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;20&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;40&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;50&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;11&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;12&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;13&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;14&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;17&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;))&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Simple, but satisfying.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;review-feedback&quot;&gt;Review Feedback&lt;&#x2F;h2&gt;
&lt;p&gt;Most of the comments were around naming (I had &lt;code&gt;DstVec&lt;&#x2F;code&gt;, &lt;code&gt;Dst&lt;&#x2F;code&gt;, &lt;code&gt;Result&lt;&#x2F;code&gt; all floating around with conflicting meanings) and LLVM&#x27;s legendary formatting rules. There&#x27;s a rule about 80 columns. It’s not just a suggestion.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#c82728;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(SubElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; BaseElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;(BaseElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; SubElements) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That became:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#f9f9f9;color:#111111;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;assert(SubElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; BaseElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;&amp;amp;&amp;amp;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;       (BaseElements &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt; SubElements) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#3e999f;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f07219;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#4271ae;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(The reviewers and the llvm bot &lt;em&gt;will&lt;&#x2F;em&gt; notice.)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;merge&quot;&gt;Merge!&lt;&#x2F;h2&gt;
&lt;p&gt;Eventually, the reviewers signed off. CI passed. I rebased, squashed, and hit &quot;Mark as ready&quot;. A few hours later, it was merged.&lt;&#x2F;p&gt;
&lt;p&gt;🎉 First LLVM patch in!&lt;&#x2F;p&gt;
&lt;p&gt;PR: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;pull&#x2F;158778&quot;&gt;llvm&#x2F;llvm-project&#x2F;pull&#x2F;158778&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Issue: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;llvm&#x2F;llvm-project&#x2F;issues&#x2F;157709&quot;&gt;#157709&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;closing-thoughts&quot;&gt;Closing Thoughts&lt;&#x2F;h2&gt;
&lt;p&gt;I learned more than I expected:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;About &lt;code&gt;constexpr&lt;&#x2F;code&gt;, sure. But also about Clang internals, how intrinsics flow through the frontend, and the lovely balance between AST and interpreter.&lt;&#x2F;li&gt;
&lt;li&gt;LLVM has a steep curve, but the community’s been welcoming and helpful. (Special thanks to the reviewers!)&lt;&#x2F;li&gt;
&lt;li&gt;It felt good to contribute something useful. Even if it&#x27;s &quot;just&quot; &lt;code&gt;constexpr&lt;&#x2F;code&gt; for a few AVX intrinsics, it&#x27;s a real feature used by real code.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;media0.giphy.com&#x2F;media&#x2F;v1.Y2lkPTc5MGI3NjExeTg3YTY0MGZ0cnVsNDEwemg1bjM1dWV0ZGMyaWt4aWc4NjZja3c0dSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw&#x2F;BMR4cgypuglVu&#x2F;giphy.gif&quot; alt=&quot;fabulous cat&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</content>
        
    </entry>
</feed>
